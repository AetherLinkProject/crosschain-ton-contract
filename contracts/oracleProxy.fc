#include "imports/stdlib.fc";
#include "const.fc";
#include "utility.fc";

;;
;; Storage
;;
;; int   oracle node count
;; int   epochId for oracle node consensus
;; int   fee for receive forward message
;; int   fee for send receive message
;; int   fee for proxy message to other contract
;; slice owner address
;; cell  white oracle address dictionary
;; cell  white contract address dictionary
;; cell  public key dictionary
;;
(int, int, int, int, int, slice, cell, cell, cell, slice) load_data() {
    slice ds = get_data().begin_parse();
    slice commonInfo = ds~load_ref().begin_parse();
    int oracleNodeCount = commonInfo~load_uint(32);
    int epochId = commonInfo~load_uint(64);
    int forwardFee = commonInfo~load_uint(32);
    int receiveFee = commonInfo~load_uint(32);
    int proxyFee = commonInfo~load_uint(32);
    slice owner = commonInfo~load_msg_addr();

    cell whiteOracleAddress = ds~load_dict();
    cell whiteContractAddress = ds~load_dict();
    cell publicKeyDic = ds~load_dict();
    slice multiSigWalletAddress = ds~load_msg_addr(); 

    return (oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress);
}

() save_data(int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress) impure inline_ref {
    cell commonInfo = begin_cell()
        .store_uint(oracleNodeCount, 32)
        .store_uint(epochId, 64)
        .store_uint(forwardFee, 32)
        .store_uint(receiveFee, 32)
        .store_uint(proxyFee, 32)
        .store_slice(owner)
        .end_cell();

    set_data(begin_cell()
        .store_ref(commonInfo)
        .store_dict(whiteOracleAddress)
        .store_dict(whiteContractAddress)
        .store_dict(publicKeyDic)
        .store_slice(multiSigWalletAddress)
        .end_cell());
}

(int) check_address_in_dic(cell dic, slice address) inline_ref {
    if (dic.dict_empty?()) {
        return 0;
    }

    int hash = address.slice_hash();
    (slice data, _) = dic.udict_get?(256, hash);
    if (data.null?()) {
        return 0;
    }

    return -1;
}

(int, cell) load_used_messages() {
    slice ds = get_data().begin_parse();
    ds~load_ref(); 
    cell usedMessages = ds~load_dict();
    return (usedMessages.dict_empty?() ? 0 : -1, usedMessages);
}

() validate_multi_sign(int oracleNodeCount, cell publicKeyDic, int reportHash, slice input_body) impure inline_ref {
    cell signDataDic = input_body~load_ref();
    slice signDicSlice = signDataDic.begin_parse();
    cell signDic = signDicSlice~load_dict();

    throw_unless(rsp::InputDataError, signDicSlice.slice_empty?());

    (int publicIndex, slice signatureRef, int flag) = signDic.udict_get_min?(256);
    int signCount = 0;
    int leastSignerCount = (oracleNodeCount / 2) + 1;
    while (flag) {
        (slice publicKeySlice, _) = publicKeyDic.udict_get?(256, publicIndex);
        throw_unless(rsp::NotInWhiteList, ~ publicKeySlice.null?());
        int publicKey = publicKeySlice~load_uint(256);
        slice signature = signatureRef~load_ref().begin_parse();

        if (check_signature(reportHash, signature, publicKey)) {
            signCount = signCount + 1;
        }

        (publicIndex, signatureRef, flag) = signDic.udict_get_next?(256, publicIndex);
    }

    throw_unless(rsp::SignerNotEnough, signCount >= leastSignerCount);
}

() forward_message(int oracleNodeCount, cell whiteOracleAddress, int proxyFee, cell publicKeyDic, slice sender, slice in_msg_body) impure inline_ref {
    ;; check
    throw_unless(rsp::PermissionDenied, check_address_in_dic(whiteOracleAddress, sender));

    int messageId = in_msg_body~load_int(128);
    (int exists, cell usedMessages) = load_used_messages();
    
    ;; throw_unless(rsp::ReplayAttackDetected(), exists == 0);
    usedMessages~udict_set(128, messageId, "true");

    slice addr = in_msg_body~load_msg_addr();
    throw_unless(rsp::InputDataError, ~ equal_slices(addr, my_address()));

    cell body = in_msg_body~load_ref();

    int reportHash = begin_cell().store_int(messageId, 128)
        .store_slice(addr)
        .store_ref(body)
        .end_cell()
        .cell_hash();

    validate_multi_sign(oracleNodeCount, publicKeyDic, reportHash, in_msg_body);

    cell proxyBody = begin_cell()
        .store_int(messageId, 128)
        .store_ref(body)
        .end_cell();

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_coins(proxyFee)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::ProxyTransactionToTon, 32)
        .store_slice(proxyBody.begin_parse())
        .end_cell();

    send_raw_message(msg, 1);
}

() receive_message(int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress, slice sender, slice in_msg_body) impure inline {
    ;; throw_unless(rsp::PermissionDenied, ~ equal_slices(owner,sender));
    throw_unless(rsp::NotInWhiteList, check_address_in_dic(whiteContractAddress, sender));

    epochId += 1;
    save_data(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress);

    ;; target chain id
    int targetChainId = in_msg_body~load_int(32);

    ;; target contract address
    cell targetContractCell = in_msg_body~load_ref();

    ;; orignal data
    cell orignalData = in_msg_body~load_ref();
    builder msgBody = begin_cell()
        .store_int(epochId, 64)
        .store_int(targetChainId, 32)
        .store_ref(targetContractCell)
        .store_slice(sender)
        .store_ref(orignalData);

    ;; extra data
    cell extraData = in_msg_body~load_ref();

    if (~ extraData.null?()) {
        msgBody = msgBody.store_ref(extraData);
    }

    throw_unless(rsp::InputDataError, in_msg_body.slice_empty?());  

    emit_log_simple(op::ProxyTransactionToOtherChain,msgBody.end_cell(), -1);

    return ();
}

() upsert_white_contract_address(int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKey, slice multiSigWalletAddress, slice sender, slice in_msg_body) impure inline {
    ;; throw_unless(rsp::NotOwner, equal_slices(owner, sender));
    (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));
    if (whiteContractAddress.dict_empty?()) {
        whiteContractAddress = new_dict();
    }

    slice address = in_msg_body~load_msg_addr();

    int inputAddrHash = address.slice_hash();
    whiteContractAddress~udict_set(256, inputAddrHash, "true");

    save_data(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKey, multiSigWalletAddress);
}

() upsert_white_oracle_address(int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress, slice sender, slice in_msg_body) impure inline {
    ;; throw_unless(rsp::NotOwner, equal_slices(owner, sender));
    (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));

    if (whiteOracleAddress.dict_empty?()) {
        whiteOracleAddress = new_dict();
    }

    int op = in_msg_body~load_int(8);

    slice address = in_msg_body~load_msg_addr();

    ;; set public key
    int publicIndex = in_msg_body~load_uint(256);
    ;; int publicKey = in_msg_body~load_uint(256);
    ;; cell publicKeyCell = begin_cell().store_uint(publicKey, 256).end_cell();
    ;; slice publicKeySlice = publicKeyCell.begin_parse();
    slice publicKeySlice = in_msg_body~load_bits(256);

    ;; set white wallet address
    int inputAddrHash = address.slice_hash();

    if (op == OracleNodeOp::Upsert) {
        publicKeyDic~udict_set(256, publicIndex, publicKeySlice);
        whiteOracleAddress~udict_set(256, inputAddrHash, "true");
    } elseif (op == OracleNodeOp::Delete) {
        (slice queryPublick, _) = publicKeyDic.udict_get?(256, publicIndex);
        throw_unless(rsp::InputDataError, equal_slices(queryPublick, publicKeySlice));

        publicKeyDic~udict_delete?(256, publicIndex);
        whiteOracleAddress~udict_delete?(256, inputAddrHash);
    } else {
        throw(rsp::InputDataError); 
    }

    save_data(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress);
}

() withdraw(slice owner, slice sender, slice in_msg_body) impure inline {
    (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));

    int withdrawAmount = in_msg_body~load_uint(256);
    slice addr = in_msg_body~load_msg_addr();

    [int balance, _] = get_balance();
    int gas = 10000000;

    throw_unless(rsp::BalanceNotEnough, balance >= (withdrawAmount + gas));

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_coins(withdrawAmount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();

    send_raw_message(msg, 0);
}

() update_oracle_node_count(int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress, slice sender, slice in_msg_body) impure inline {
    ;; throw_unless(rsp::NotOwner, equal_slices(owner, sender));
    (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));

    int latestOracleNodeCount = in_msg_body~load_uint(32);
    if (oracleNodeCount == latestOracleNodeCount) {
        return ();
    }

    throw_unless(rsp::InputDataError, latestOracleNodeCount >= 3);

    save_data(latestOracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress);
}

() notify_resend_needed(int oracleNodeCount, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice sender, slice in_msg_body) impure inline {
    throw_unless(rsp::PermissionDenied, check_address_in_dic(whiteContractAddress, sender));

    int messageId = in_msg_body~load_int(128);

    throw_unless(rsp::InputDataError, in_msg_body~load_int(8) == resend::AppointTime);

    int maxDelaySeconds = 60 * 60 * 24;
    throw_unless(rsp::InputDataError, maxDelaySeconds > in_msg_body~load_int(32));

    builder logData = begin_cell()
        .store_int(messageId, 128)
        .store_slice(sender)
        .store_slice(my_address()) 
        .store_int(now(), 64);  
    
    emit_log_simple(op::NotifyResendNeeded, logData.end_cell(), -1);
}

() update_fee(int oracleNodeCount, int epochId, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress, slice sender, slice in_msg_body) impure inline {
    ;; throw_unless(rsp::NotOwner, equal_slices(owner, sender));
    (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));

    int latestForwardFee = in_msg_body~load_uint(32);
    int latestReceiveFee = in_msg_body~load_uint(32);
    int latestProxyFee = in_msg_body~load_uint(32);

    throw_unless(rsp::InputDataError, latestForwardFee > 0);
    throw_unless(rsp::InputDataError, latestReceiveFee > 0);
    throw_unless(rsp::InputDataError, latestProxyFee > 0);

    save_data(oracleNodeCount, epochId, latestForwardFee, latestReceiveFee, latestProxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress);
}

() update_contract_code(slice owner, slice sender, slice in_msg_body) impure {
    (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));
    ;; (_, _, _, _, _, _, _, _, _, slice multiSigWalletAddress) = load_data();
    ;; throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));

    cell code = in_msg_body~load_ref();
    set_code(code);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        return ();
    }

    int op = in_msg_body~load_int(32);
    slice sender = cs~load_msg_addr();
    ;;
    ;; if (op == op::RecordLog()) {
    ;;     throw_unless(rsp::PermissionDenied, equal_slices(sender, my_address()));
    ;;     ;; for record log
    ;;     return ();
    ;; }

    (int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress) = load_data();

    if (op == op::ProxyTransactionToTon) {
        throw_unless(rsp::FeeToLow, msg_value >= forwardFee);
        forward_message(oracleNodeCount, whiteOracleAddress, proxyFee, publicKeyDic, sender, in_msg_body);
        return ();
    }

    if (op == op::ProxyTransactionToOtherChain) {
        throw_unless(rsp::FeeToLow, msg_value >= receiveFee);
        receive_message(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress, sender, in_msg_body);
        return ();
    }

    ;; add ton white contract address
    if (op == op::UpsertWhiteContractAddress) {
        upsert_white_contract_address(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress, sender, in_msg_body);
        return ();
    }

    ;; add white wallet address
    if (op == op::UpsertWhiteOracleAddress) {
        upsert_white_oracle_address(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress, sender, in_msg_body);
        return ();
    }

    if (op == op::ResendTx) {
        throw_unless(rsp::FeeToLow, msg_value >= forwardFee);
        notify_resend_needed(oracleNodeCount, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender, in_msg_body);
        return ();
    }

    if (op == op::Withdraw) {
        withdraw(owner, sender, in_msg_body);
        return ();
    }

    if (op == op::UpdateOracleNodeCount) {
        update_oracle_node_count(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress, sender, in_msg_body);
        return ();
    }

    if (op == op::UpdateCode) {
        update_contract_code(owner, sender, in_msg_body);
        return ();
    }

    if (op == op::UpdateFee) {
        update_fee(oracleNodeCount, epochId, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, multiSigWalletAddress, sender, in_msg_body);
        return ();
    }

    throw(rsp::OperateNotMatch);
}

() save_used_messages(cell usedMessages) impure inline_ref {
    (int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress) = load_data();
    
    set_data(begin_cell()
        .store_ref(begin_cell()
            .store_uint(oracleNodeCount, 32)
            .store_uint(epochId, 64)
            .store_uint(forwardFee, 32)
            .store_uint(receiveFee, 32)
            .store_uint(proxyFee, 32)
            .store_slice(owner)
            .end_cell()
        )
        .store_dict(whiteOracleAddress)
        .store_dict(whiteContractAddress)
        .store_dict(publicKeyDic)
        .store_dict(usedMessages) ;; recode used messageId
        .end_cell());
}

() set_multisig_wallet_address(slice sender, slice in_msg_body) impure {
    (int oracleNodeCount, int epochId, int forwardFee, int receiveFee, int proxyFee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice multiSigWalletAddress) = load_data();
    
    slice newMultiSigWalletAddress = in_msg_body~load_msg_addr();
    
    throw_unless(rsp::MultiSigInvalidUpdate, newMultiSigWalletAddress.slice_empty?() == 0);

    if (multiSigWalletAddress.slice_empty?() != 0) {
        throw_unless(rsp::NotOwner, equal_slices(sender, owner));
    } else {
        throw_unless(rsp::NotMultiSig, equal_slices(sender, multiSigWalletAddress));
    }

    save_data(oracleNodeCount, epochId, forwardFee, receiveFee, proxyFee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, newMultiSigWalletAddress);
}

;;
;; check contract address in whiteaddresses
;;
;; ruturn -1:true , 0:false
;;
(int) check_contract_address_has_permission(cell contractAddress) method_id {
    (_, _, _, _, _, _, _, cell whiteContractAddress, _, _) = load_data();  
    slice address = contractAddress.begin_parse();
    return check_address_in_dic(whiteContractAddress, address);
}

;;
;; check oracle address in whiteaddresses
;;
;; ruturn -1:true , 0:false
;;
(int) check_oracle_address_has_permission(cell walletAddress) method_id {
    (_, _, _, _, _, _, cell whiteWalletAddress, _, _, _) = load_data();
    return check_address_in_dic(whiteWalletAddress, walletAddress.begin_parse());
}

(int) get_oracle_node_count() method_id {
    (int oracleNodeCount, _, _, _, _, _, _, _, _, _) = load_data();
    return oracleNodeCount;
}

(int) get_resume_balance() method_id {
    [int balance, _] = get_balance();

    return balance;
}

(int, int, int) get_current_fee() method_id {
    (_, _, int forwardFee, int receiveFee, int proxyFee, _, _, _, _, _) = load_data();

    return (forwardFee, receiveFee, proxyFee);
}