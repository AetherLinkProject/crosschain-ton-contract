#include "imports/stdlib.fc";
#include "const.fc";

;;
;; Storage
;;
;; int   oracle node count
;; int   epochId for oracle node consensus
;; int   fee for forward or receive
;; slice owner address
;; cell  white oracle address dictionary
;; cell  white contract address dictionary
;; cell  public key dictionary
;;
(int, int, int, slice, cell, cell, cell) load_data() {
    slice ds = get_data().begin_parse();
    slice commonInfo = ds~load_ref().begin_parse();
    int oracleNodeCount = commonInfo~load_uint(32);
    int epochId = commonInfo~load_uint(64);
    int fee = commonInfo~load_uint(32);
    slice owner = commonInfo~load_msg_addr();

    cell whiteOracleAddress = ds~load_dict();
    cell whiteContractAddress = ds~load_dict();
    cell publicKeyDic = ds~load_dict();

    return (oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic);
}

() save_data(int oracleNodeCount, int epochId, int fee ,slice owner, cell whiteOracleAddress,cell whiteContractAddress, cell publicKeyDic) impure inline_ref {
    cell commonInfo = begin_cell()
        .store_uint(oracleNodeCount, 32)
        .store_uint(epochId,64)
        .store_uint(fee,32)
        .store_slice(owner)
        .end_cell();

    set_data(begin_cell()
        .store_ref(commonInfo)
        .store_dict(whiteOracleAddress)
        .store_dict(whiteContractAddress)
        .store_dict(publicKeyDic)
        .end_cell());
}

(int) check_address_in_dic(cell dic, slice address) inline_ref {
    if(dic.null?()){
        return 0;
    }

    if(dic.dict_empty?()){
        return 0;
    }

    int hash = address.slice_hash();
    (slice data, _) = dic.udict_get?(256,hash);
    if(data.null?()){
        return 0;
    }

    return -1;
}

() validate_multi_sign(int oracleNodeCount, cell publicKeyDic, int hash,  slice input_body) impure inline_ref {
    cell signDataDic = input_body~load_ref();
    slice signDicSlice = signDataDic.begin_parse();
    cell signDic = signDicSlice~load_dict();
    (int publickIndex, slice signatureRef, int flag) = signDic.udict_get_min?(256);
    int signCount = 0;

    while(flag){
        ;; get public key
        (slice publicKeySlice, _) = publicKeyDic.udict_get?(256,publickIndex);
        throw_unless(rsp::NotInWhiteList, ~ publicKeySlice.null?());

        int publicKey = publicKeySlice~load_uint(256);
        slice signature = signatureRef~load_ref().begin_parse();

        throw_unless(rsp::SignatureError, check_signature(hash, signature, publicKey));

        signCount = signCount + 1;

        (publickIndex, signatureRef, flag) = signDic.udict_get_next?(256, publickIndex);
    }

    int leastSignerCount = (oracleNodeCount / 2) + 1;

    ;; recheck sign count
    throw_unless(rsp::SignerNotEnough, signCount >= leastSignerCount);
}

() forward_message(int oracleNodeCount, cell whiteOracleAddress, cell publicKeyDic, slice sender,  slice in_msg_body) impure inline_ref {
    ;; check
    throw_unless(rsp::PermissionDenied, check_address_in_dic(whiteOracleAddress, sender));

    int messageId = in_msg_body~load_int(256);
    slice addr = in_msg_body~load_msg_addr();

    cell body = in_msg_body~load_ref();

    int originalHash = begin_cell().store_int(messageId,256)
        .store_slice(addr)
        .store_ref(body)
        .end_cell()
        .cell_hash();

    validate_multi_sign(oracleNodeCount, publicKeyDic, originalHash,in_msg_body);

    cell proxyBody = begin_cell()
        .store_int(messageId, 256)
        .store_ref(body)
        .end_cell();

    int gas_fee = 10000000;
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_coins(gas_fee)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::ProxyTransactionToTon(), 32)
        .store_slice(proxyBody.begin_parse())
        .end_cell();

    send_raw_message(msg, 1);
}

() receive_message(int oracleNodeCount, int epochId, int fee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic,slice sender,  slice in_msg_body) impure inline {
    throw_unless(rsp::PermissionDenied, ~ equal_slices(owner,sender));

    throw_unless(rsp::NotInWhiteList, check_address_in_dic(whiteContractAddress, sender));

    epochId += 1;

    save_data(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic);

    return ();
}

() upsert_white_contract_address(int oracleNodeCount, int epochId, int fee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKey,slice sender,  slice in_msg_body) impure inline {
    throw_unless(rsp::NotOwner, equal_slices(owner, sender));
    if(whiteContractAddress.dict_empty?()){
        whiteContractAddress = new_dict();
    }

    slice address = in_msg_body~load_msg_addr();
    if(address.slice_data_empty?()){
        return ();
    }

    int inputAddrHash = address.slice_hash();
    whiteContractAddress~udict_set(256, inputAddrHash, "true");

    save_data(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKey);
}

() upsert_white_oracle_address(int oracleNodeCount, int epochId, int fee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice sender,  slice in_msg_body) impure inline {
    throw_unless(rsp::NotOwner, equal_slices(owner, sender));

    if(whiteOracleAddress.dict_empty?()){
        whiteOracleAddress = new_dict();
    }

    int op = in_msg_body~load_int(8);

    slice address = in_msg_body~load_msg_addr();
    if(address.slice_data_empty?()){
        throw(rsp::InputDataError);
    }

    ;; set public key
    int publicIndex = in_msg_body~load_int(256);
    int publicKey = in_msg_body~load_int(256);
    cell publicKeyCell = begin_cell().store_int(publicKey, 256).end_cell();
    slice publicKeySlice = publicKeyCell.begin_parse();

    ;; set white wallet address
    int inputAddrHash = address.slice_hash();

    if(op == OracleNodeOp::Upsert()){
        publicKeyDic~udict_set(256, publicIndex, publicKeySlice);
        whiteOracleAddress~udict_set(256, inputAddrHash, "true");
    } elseif (op == OracleNodeOp::Delete()){
        (slice queryPublick, _) = publicKeyDic.udict_get?(256, publicIndex);
        throw_unless(rsp::InputDataError, equal_slices(queryPublick, publicKeySlice));

        publicKeyDic~udict_delete?(256, publicIndex);
        whiteOracleAddress~udict_delete?(256, inputAddrHash);
    } else {
        return ();
    }

    save_data(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic);
}

() withdraw(slice owner, slice sender, slice in_msg_body) impure inline {
    throw_unless(rsp::NotOwner, equal_slices(owner,sender));

    int withdrawAmount = in_msg_body~load_int(256);
    slice addr = in_msg_body~load_msg_addr();

    [int balance, _] = get_balance();
    int gas = 10000000;
    if(balance < (withdrawAmount + gas)){
        throw(rsp::BalanceNotEnough);
    }

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_coins(withdrawAmount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();

    send_raw_message(msg, 0);
}

() update_oracle_node_count(int oracleNodeCount, int epochId, int fee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice sender,  slice in_msg_body) impure inline {
    throw_unless(rsp::NotOwner, equal_slices(owner, sender));

    int latestOracleNodeCount = in_msg_body~load_int(32);
    if(oracleNodeCount == latestOracleNodeCount){
        return ();
    }

    throw_unless(rsp::InputDataError, latestOracleNodeCount >= 3);

    save_data(latestOracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic);
}

() resend(int oracleNodeCount, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice sender,  slice in_msg_body) impure inline {
    ;; check sender
    throw_unless(rsp::PermissionDenied, check_address_in_dic(whiteContractAddress, sender));

    ;; try anlaysis in_msg_body
    int messageId = in_msg_body~load_int(256);

    throw_unless(rsp::InputDataError, in_msg_body~load_int(8) == resend::AppointTime());

    int maxDelaySeconds = 60 * 60 * 24;
    throw_unless(rsp::InputDataError, maxDelaySeconds < in_msg_body~load_int(32));
}

() update_fee(int oracleNodeCount, int epochId, int fee, slice owner, cell whiteOracleAddress, cell whiteContractAddress, cell publicKeyDic, slice sender,  slice in_msg_body) impure inline {
    throw_unless(rsp::NotOwner, equal_slices(owner,sender));

    int latest = in_msg_body~load_uint(32);
    if(fee == latest){
        return ();
    }

    throw_unless(rsp::InputDataError, latest > 0);

    save_data(oracleNodeCount, epochId, latest, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        return ();
    }

    (int oracleNodeCount, int epochId, int fee, slice owner, cell whiteOracleAddress,cell whiteContractAddress, cell publicKeyDic) = load_data();
    int op = in_msg_body~load_int(32);
    slice sender = cs~load_msg_addr();

    if(op == op::ProxyTransactionToTon()){
        throw_unless(rsp::FeeToLow, msg_value >= fee);
        forward_message(oracleNodeCount, whiteOracleAddress, publicKeyDic, sender, in_msg_body);
        return ();
    }

    if(op == op::ProxyTransactionToOtherChain()){
        throw_unless(rsp::FeeToLow, msg_value >= fee);
        receive_message(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender,  in_msg_body);
        return ();
    }

    ;; add ton white contract address
    if(op == op::UpsertWhiteContractAddress()){
        upsert_white_contract_address(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender,  in_msg_body);
        return ();
    }

    ;; add white wallet address
    if(op == op::UpsertWhiteOracleAddress()){
        upsert_white_oracle_address(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender, in_msg_body);
        return ();
    }

    if(op == op::ResendTx()){
        throw_unless(rsp::FeeToLow, msg_value >= fee);
        resend(oracleNodeCount, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender, in_msg_body);
        return();
    }

    if(op == op::Withdraw()){
        withdraw(owner, sender, in_msg_body);
        return();
    }

    if(op == op::UpdateOracleNodeCount()){
        update_oracle_node_count(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender, in_msg_body);
        return ();
    }

    if(op == op:UpdateFee()){
        update_fee(oracleNodeCount, epochId, fee, owner, whiteOracleAddress, whiteContractAddress, publicKeyDic, sender, in_msg_body);
        return();
    }

    throw(rsp::OperateNotMatch);
}

;;
;; check contract address in whiteaddresses
;;
;; ruturn -1:ture , 0:false
;;
(int) check_contract_address_has_permission(cell contractAddress) method_id {
    (_, _,_,_,_, cell whiteContractAddress, _) = load_data();
    slice address = contractAddress.begin_parse();
    return check_address_in_dic(whiteContractAddress, address);
}

;;
;; check oracle address in whiteaddresses
;;
;; ruturn -1:ture , 0:false
;;
(int) check_oracle_address_has_permission(cell walletAddress) method_id {
    (_, _, _, _, cell whiteWalletAddress , _, _) = load_data();
    return check_address_in_dic(whiteWalletAddress, walletAddress.begin_parse());
}

(int) get_oracle_node_count() method_id {
    (int oracleNodeCount,_, _, _, _, _, _) = load_data();
    return oracleNodeCount;
}

(int) get_resume_balance() method_id {
    [int balance, _] = get_balance();

    return balance;
}

(int) get_current_fee() method_id {
    (_,_,int fee,_,_,_,_) = load_data();
    return fee;
}